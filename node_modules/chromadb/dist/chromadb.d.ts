import { createClient } from '@hey-api/client-fetch';

type CollectionConfiguration = {
    embedding_function?: null | EmbeddingFunctionConfiguration;
    hnsw?: null | HnswConfiguration;
    spann?: null | SpannConfiguration;
};
type Database = {
    id: string;
    name: string;
    tenant: string;
};
type EmbeddingFunctionConfiguration = {
    type: 'legacy';
} | (EmbeddingFunctionNewConfiguration & {
    type: 'known';
});
type EmbeddingFunctionNewConfiguration = {
    config: unknown;
    name: string;
};
type GetUserIdentityResponse = {
    databases: Array<string>;
    tenant: string;
    user_id: string;
};
type HnswConfiguration = {
    ef_construction?: number | null;
    ef_search?: number | null;
    max_neighbors?: number | null;
    resize_factor?: number | null;
    space?: HnswSpace;
    sync_threshold?: number | null;
};
type HnswSpace = 'l2' | 'cosine' | 'ip';
type Include = 'distances' | 'documents' | 'embeddings' | 'metadatas' | 'uris';
type SpannConfiguration = {
    ef_construction?: number | null;
    ef_search?: number | null;
    max_neighbors?: number | null;
    merge_threshold?: number | null;
    reassign_neighbor_count?: number | null;
    search_nprobe?: number | null;
    space?: HnswSpace;
    split_threshold?: number | null;
    write_nprobe?: number | null;
};
type UpdateCollectionConfiguration = {
    embedding_function?: null | EmbeddingFunctionConfiguration;
    hnsw?: null | UpdateHnswConfiguration;
    spann?: null | SpannConfiguration;
};
type UpdateHnswConfiguration = {
    batch_size?: number | null;
    ef_search?: number | null;
    max_neighbors?: number | null;
    num_threads?: number | null;
    resize_factor?: number | null;
    sync_threshold?: number | null;
};

type UserIdentity = GetUserIdentityResponse;
type CollectionMetadata = Record<string, boolean | number | string>;
type Metadata = Record<string, boolean | number | string>;
type LiteralValue = string | number | boolean;
type OperatorExpression = {
    $gt: LiteralValue;
} | {
    $gte: LiteralValue;
} | {
    $lt: LiteralValue;
} | {
    $lte: LiteralValue;
} | {
    $ne: LiteralValue;
} | {
    $eq: LiteralValue;
} | {
    $and: LiteralValue;
} | {
    $or: LiteralValue;
} | {
    $in: LiteralValue[];
} | {
    $nin: LiteralValue[];
};
type Where = {
    [key: string]: LiteralValue | OperatorExpression;
} | {
    $and: Where[];
} | {
    $or: Where[];
};
type WhereDocument = {
    $contains: string;
} | {
    $not_contains: string;
} | {
    $matches: string;
} | {
    $not_matches: string;
} | {
    $and: WhereDocument[];
} | {
    $or: WhereDocument[];
};
declare class GetResult<TMeta extends Metadata = Metadata> {
    readonly documents: (string | null)[];
    readonly embeddings: number[][];
    readonly ids: string[];
    readonly include: Include[];
    readonly metadatas: (TMeta | null)[];
    readonly uris: (string | null)[];
    constructor({ documents, embeddings, ids, include, metadatas, uris, }: {
        documents: (string | null)[];
        embeddings: number[][];
        ids: string[];
        include: Include[];
        metadatas: (TMeta | null)[];
        uris: (string | null)[];
    });
    rows(): {
        include: Include[];
        records: {
            id: string;
            document: string | null | undefined;
            embedding: number[] | undefined;
            metadata: TMeta | null | undefined;
            uri: string | null | undefined;
        }[];
    };
}
interface QueryRowResult<TMeta extends Metadata = Metadata> {
    include: Include[];
    queries: {
        distance?: number | null;
        document?: string | null;
        embedding?: number[] | null;
        id: string;
        metadata?: TMeta | null;
        uri?: string | null;
    }[][];
}
declare class QueryResult<TMeta extends Metadata = Metadata> {
    readonly distances: (number | null)[][];
    readonly documents: (string | null)[][];
    readonly embeddings: (number[] | null)[][];
    readonly ids: string[][];
    readonly include: Include[];
    readonly metadatas: (TMeta | null)[][];
    readonly uris: (string | null)[][];
    constructor({ distances, documents, embeddings, ids, include, metadatas, uris, }: {
        distances: (number | null)[][];
        documents: (string | null)[][];
        embeddings: (number[] | null)[][];
        ids: string[][];
        include: Include[];
        metadatas: (TMeta | null)[][];
        uris: (string | null)[][];
    });
    rows(): QueryRowResult<TMeta>;
}

type EmbeddingFunctionSpace = "cosine" | "l2" | "ip";
interface EmbeddingFunction {
    generate(texts: string[]): Promise<number[][]>;
    name?: string;
    defaultSpace?(): EmbeddingFunctionSpace;
    supportedSpaces?(): EmbeddingFunctionSpace[];
    buildFromConfig?(config: Record<string, any>): EmbeddingFunction;
    getConfig?(): Record<string, any>;
    validateConfigUpdate?(oldConfig: Record<string, any>, newConfig: Record<string, any>): void;
    validateConfig?(config: Record<string, any>): void;
}
interface EmbeddingFunctionClass {
    new (...args: any[]): EmbeddingFunction;
    name: string;
    buildFromConfig(config: Record<string, any>): EmbeddingFunction;
}
declare class MalformedEmbeddingFunction implements EmbeddingFunction {
    readonly name: string;
    constructor(collectionName: string, message: string);
    generate(texts: string[]): Promise<number[][]>;
}
declare const knownEmbeddingFunctions: Map<string, EmbeddingFunctionClass>;
declare const registerEmbeddingFunction: (name: string, fn: EmbeddingFunctionClass) => void;
declare const getEmbeddingFunction: (collectionName: string, efConfig?: EmbeddingFunctionConfiguration) => Promise<EmbeddingFunction | MalformedEmbeddingFunction>;
declare const serializeEmbeddingFunction: (ef: EmbeddingFunction) => EmbeddingFunctionConfiguration;
declare const getDefaultEFConfig: () => Promise<EmbeddingFunctionConfiguration>;

interface ChromaClientArgs {
    host?: string;
    port?: number;
    ssl?: boolean;
    tenant?: string;
    database?: string;
    headers?: Record<string, string>;
    fetchOptions?: RequestInit;
}
declare class ChromaClient {
    private _tenant;
    private _database;
    private readonly apiClient;
    constructor(args?: Partial<ChromaClientArgs>);
    get tenant(): string | undefined;
    protected set tenant(tenant: string | undefined);
    get database(): string | undefined;
    protected set database(database: string | undefined);
    /** @ignore */
    _path(): Promise<{
        tenant: string;
        database: string;
    }>;
    getUserIdentity(): Promise<UserIdentity>;
    heartbeat(): Promise<number>;
    listCollections(args?: Partial<{
        limit: number;
        offset: number;
    }>): Promise<Collection[]>;
    countCollections(): Promise<number>;
    createCollection({ name, configuration, metadata, embeddingFunction, }: {
        name: string;
        configuration?: CollectionConfiguration;
        metadata?: CollectionMetadata;
        embeddingFunction?: EmbeddingFunction;
    }): Promise<Collection>;
    getCollection({ name, embeddingFunction, }: {
        name: string;
        embeddingFunction?: EmbeddingFunction;
    }): Promise<Collection>;
    getCollections(items: string[] | {
        name: string;
        embeddingFunction?: EmbeddingFunction;
    }[]): Promise<void[]>;
    getOrCreateCollection({ name, configuration, metadata, embeddingFunction, }: {
        name: string;
        configuration?: CollectionConfiguration;
        metadata?: CollectionMetadata;
        embeddingFunction?: EmbeddingFunction;
    }): Promise<Collection>;
    deleteCollection({ name }: {
        name: string;
    }): Promise<void>;
    reset(): Promise<void>;
    version(): Promise<string>;
    collection({ id, embeddingFunction, }: {
        id: string;
        embeddingFunction?: EmbeddingFunction;
    }): CollectionAPI;
    collections(items: string[] | {
        id: string;
        embeddingFunction?: EmbeddingFunction;
    }[]): CollectionAPIImpl[];
}

interface CollectionAPI {
    id: string;
    embeddingFunction?: EmbeddingFunction;
    count(): Promise<number>;
    add(args: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    get<TMeta extends Metadata = Metadata>(args?: {
        ids?: string[];
        where?: Where;
        limit?: number;
        offset?: number;
        whereDocument?: WhereDocument;
        include?: Include[];
    }): Promise<GetResult<TMeta>>;
    peek(args: {
        limit?: number;
    }): Promise<GetResult>;
    query<TMeta extends Metadata = Metadata>(args: {
        queryEmbeddings?: number[][];
        queryTexts?: string[];
        queryURIs?: string[];
        ids?: string[];
        nResults?: number;
        where?: Where;
        whereDocument?: WhereDocument;
        include?: Include[];
    }): Promise<QueryResult<TMeta>>;
    modify(args: {
        name?: string;
        metadata?: CollectionMetadata;
        configuration?: UpdateCollectionConfiguration;
    }): Promise<void>;
    fork({ name }: {
        name: string;
    }): Promise<Collection>;
    update(args: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    upsert(args: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    delete(args: {
        ids?: string[];
        where?: Where;
        whereDocument?: WhereDocument;
    }): Promise<void>;
}
interface Collection extends CollectionAPI {
    name: string;
    embeddingFunction: EmbeddingFunction;
    metadata: CollectionMetadata | undefined;
    configuration: CollectionConfiguration;
}
declare class CollectionAPIImpl implements CollectionAPI {
    protected readonly chromaClient: ChromaClient;
    protected readonly apiClient: ReturnType<typeof createClient>;
    readonly id: string;
    protected _embeddingFunction: EmbeddingFunction | undefined;
    constructor({ chromaClient, apiClient, id, embeddingFunction, }: {
        chromaClient: ChromaClient;
        apiClient: ReturnType<typeof createClient>;
        id: string;
        embeddingFunction?: EmbeddingFunction;
    });
    get embeddingFunction(): EmbeddingFunction | undefined;
    protected path(): Promise<{
        tenant: string;
        database: string;
        collection_id: string;
    }>;
    private embed;
    private prepareRecords;
    private validateGet;
    private prepareQuery;
    private validateDelete;
    count(): Promise<number>;
    add({ ids, embeddings, metadatas, documents, uris, }: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    get<TMeta extends Metadata = Metadata>(args?: Partial<{
        ids?: string[];
        where?: Where;
        limit?: number;
        offset?: number;
        whereDocument?: WhereDocument;
        include?: Include[];
    }>): Promise<GetResult<TMeta>>;
    peek({ limit }: {
        limit?: number;
    }): Promise<GetResult>;
    query<TMeta extends Metadata = Metadata>({ queryEmbeddings, queryTexts, queryURIs, ids, nResults, where, whereDocument, include, }: {
        queryEmbeddings?: number[][];
        queryTexts?: string[];
        queryURIs?: string[];
        ids?: string[];
        nResults?: number;
        where?: Where;
        whereDocument?: WhereDocument;
        include?: Include[];
    }): Promise<QueryResult<TMeta>>;
    modify({ name, metadata, configuration, }: {
        name?: string;
        metadata?: CollectionMetadata;
        configuration?: UpdateCollectionConfiguration;
    }): Promise<void>;
    fork({ name }: {
        name: string;
    }): Promise<Collection>;
    update({ ids, embeddings, metadatas, documents, uris, }: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    upsert({ ids, embeddings, metadatas, documents, uris, }: {
        ids: string[];
        embeddings?: number[][];
        metadatas?: Metadata[];
        documents?: string[];
        uris?: string[];
    }): Promise<void>;
    delete({ ids, where, whereDocument, }: {
        ids?: string[];
        where?: Where;
        whereDocument?: WhereDocument;
    }): Promise<void>;
}

interface AdminClientArgs {
    host: string;
    port: number;
    ssl: boolean;
    headers?: Record<string, string>;
    fetchOptions?: RequestInit;
}
interface ListDatabasesArgs {
    tenant: string;
    limit?: number;
    offset?: number;
}
declare class AdminClient {
    private readonly apiClient;
    constructor(args?: AdminClientArgs);
    createDatabase({ name, tenant, }: {
        name: string;
        tenant: string;
    }): Promise<void>;
    getDatabase({ name, tenant, }: {
        name: string;
        tenant: string;
    }): Promise<Database>;
    deleteDatabase({ name, tenant, }: {
        name: string;
        tenant: string;
    }): Promise<void>;
    listDatabases(args: ListDatabasesArgs): Promise<Database[]>;
    createTenant({ name }: {
        name: string;
    }): Promise<void>;
    getTenant({ name }: {
        name: string;
    }): Promise<string>;
}

declare class CloudClient extends ChromaClient {
    constructor(args?: Partial<{
        apiKey?: string;
        tenant?: string;
        database?: string;
        fetchOptions?: RequestInit;
    }>);
}
declare class AdminCloudClient extends AdminClient {
    constructor(args?: Partial<{
        apiKey?: string;
        fetchOptions?: RequestInit;
    }>);
}

export { AdminClient, type AdminClientArgs, AdminCloudClient, ChromaClient, type ChromaClientArgs, CloudClient, type Collection, type CollectionAPI, type EmbeddingFunction, type EmbeddingFunctionClass, type EmbeddingFunctionSpace, type ListDatabasesArgs, getDefaultEFConfig, getEmbeddingFunction, knownEmbeddingFunctions, registerEmbeddingFunction, serializeEmbeddingFunction };
